//
//                           SimuLTE
// Copyright (C) 2012 Antonio Virdis, Daniele Migliorini, Giovanni
// Accongiagioco, Generoso Pagano, Vincenzo Pii.
//
// This file is part of a software released under the license included in file
// "license.pdf". This license can be also found at http://www.ltesimulator.com/
// The above file and the present reference are part of the software itself,
// and cannot be removed from it.
//


#include "LteMacBase.h"
#include "LteHarqBufferTx.h"
#include "LteHarqBufferRx.h"
#include "LteMacPdu.h"
#include "LteMacQueue.h"
#include "LteControlInfo.h"
#include "LteBinder.h"
#include "LteDeployer.h"
#include "LteHarqFeedback_m.h"
#include "LteMacBuffer.h"
#include "assert.h"

LteMacBase::LteMacBase()
{
    mbuf_.clear();
    macBuffers_.clear();
}

LteMacBase::~LteMacBase()
{
    LteMacBuffers::iterator mit;
    LteMacBufferMap::iterator vit;
    for (mit = mbuf_.begin(); mit != mbuf_.end(); mit++)
        delete mit->second;
    for (vit = macBuffers_.begin(); vit != macBuffers_.end(); vit++)
        delete vit->second;
    mbuf_.clear();
    macBuffers_.clear();
    harqTxBuffers_.clear();
    harqRxBuffers_.clear();
}

void LteMacBase::sendUpperPackets(cPacket* pkt)
{
    EV << "LteMacBase : Sending packet " << pkt->getName() << " on port MAC_to_RLC\n";
    // Send message
    send(pkt,up_[OUT]);
    emit(sentPacketToUpperLayer, pkt);
}

void LteMacBase::sendLowerPackets(cPacket* pkt)
{
    EV << "LteMacBase : Sending packet " << pkt->getName() << " on port MAC_to_PHY\n";
    // Send message
    updateUserTxParam(pkt);
    send(pkt,down_[OUT]);
    emit(sentPacketToLowerLayer, pkt);
}

/*
 * Upper layer handler
 */
void LteMacBase::fromRlc(cPacket *pkt)
{
    bufferizePacket(pkt);
}

/*
 * Lower layer handler
 */
void LteMacBase::fromPhy(cPacket *pkt)
{
    // TODO: harq test (comment fromPhy: it has only to pass pdus to proper rx buffer and
    // to manage H-ARQ feedback)

    UserControlInfo *userInfo = check_and_cast<UserControlInfo *>(pkt->getControlInfo());
    MacNodeId src = userInfo->getSourceId();

    if (userInfo->getFrameType() == HARQPKT)
    {
        // H-ARQ feedback, send it to TX buffer of source
        HarqTxBuffers::iterator htit = harqTxBuffers_.find(src);
        EV << NOW << "Mac::fromPhy: node " << nodeId_ << " Received HARQ Feeback pkt" << endl;
        if (htit == harqTxBuffers_.end())
        {
            // if a feeback arrives, a tx buffer must exists (unless it is an handover scenario
            // where the harq buffer was deleted but a feedback was in transit)
            // this case must be taken care of
            throw cRuntimeError("Mac::fromPhy(): Received feedback for an unexisting H-ARQ tx buffer");
        }
        LteHarqFeedback *hfbpkt = check_and_cast<LteHarqFeedback *>(pkt);
        htit->second->receiveHarqFeedback(hfbpkt);
    }
    else if (userInfo->getFrameType() == FEEDBACKPKT)
    {
        //Feedback pkt
        EV << NOW << "Mac::fromPhy: node " << nodeId_ << " Received feedback pkt" << endl;
        macHandleFeedbackPkt(pkt);
    }
    else if (userInfo->getFrameType()==GRANTPKT)
    {
        //Scheduling Grant
        EV << NOW << "Mac::fromPhy: node " << nodeId_ << " Received Scheduling Grant pkt" << endl;
        macHandleGrant(pkt);
    }
    else if(userInfo->getFrameType() == DATAPKT)
    {
        // data packet: insert in proper rx buffer
        EV << NOW << "Mac::fromPhy: node " << nodeId_ << " Received DATA packet" << endl;
        LteMacPdu *pdu = check_and_cast<LteMacPdu *>(pkt);
        Codeword cw = userInfo->getCw();
        HarqRxBuffers::iterator hrit = harqRxBuffers_.find(src);
        if (hrit != harqRxBuffers_.end())
        {
            hrit->second->insertPdu(cw,pdu);
        }
        else
        {
            // FIXME: possible memory leak
            LteHarqBufferRx *hrb = new LteHarqBufferRx(ENB_RX_HARQ_PROCESSES, this,src);
            harqRxBuffers_[src] = hrb;
            hrb->insertPdu(cw,pdu);
        }
    }
    else if (userInfo->getFrameType() == RACPKT)
    {
        EV << NOW << "Mac::fromPhy: node " << nodeId_ << " Received RAC packet" << endl;
        macHandleRac(pkt);
    }
    else
    {
        throw cRuntimeError("Unknown packet type %d", (int)userInfo->getFrameType());
    }
}

bool LteMacBase::bufferizePacket(cPacket* pkt)
{
    pkt->setTimestamp();        // Add timestamp with current time to packet

    FlowControlInfo* lteInfo = check_and_cast<FlowControlInfo*>(pkt->getControlInfo());

    // obtain the cid from the packet informations
    MacCid cid = ctrlInfoToMacCid(lteInfo);

    // build the virtual packet corresponding to this incoming packet
    PacketInfo vpkt(pkt->getByteLength(), pkt->getTimestamp());

    LteMacBuffers::iterator it = mbuf_.find(cid);
    if (it == mbuf_.end())
    {
        // Queue not found for this cid: create
        LteMacQueue* queue = new LteMacQueue(queueSize_);
        LteMacBuffer* vqueue = new LteMacBuffer();

        queue->pushBack(pkt);
        vqueue->pushBack(vpkt);
        mbuf_[cid] = queue;
        macBuffers_[cid] = vqueue;

        // make a copy of lte control info and store it to traffic descriptors map
        FlowControlInfo toStore(*lteInfo);
        connDesc_[cid] = toStore;
        // register connection to lcg map.
        LteTrafficClass tClass = (LteTrafficClass) lteInfo->getTraffic();

        lcgMap_.insert(LcgPair(tClass, CidBufferPair(cid, macBuffers_[cid])));

        EV << "LteMacBuffers : Using new buffer on node: " <<
        MacCidToNodeId(cid) << " for Lcid: " << MacCidToLcid(cid) << ", Space left in the Queue: " <<
        queue->getQueueSize() - queue->getByteLength() << "\n";
    }
    else
    {
        // Found
        LteMacQueue* queue = it->second;
        LteMacBuffer* vqueue = macBuffers_.find(cid)->second;
        if (!queue->pushBack(pkt))
        {
            tSample_->id_=nodeId_;
            tSample_->sample_=pkt->getByteLength();
            if (lteInfo->getDirection()==DL)
            {
                emit(macBufferOverflowDl_,tSample_);
            }
            else
            {
                emit(macBufferOverflowUl_,tSample_);
            }

            EV << "LteMacBuffers : Dropped packet: queue" << cid << " is full\n";
            delete pkt;
            return false;
        }
        vqueue->pushBack(vpkt);

        EV << "LteMacBuffers : Using old buffer on node: " <<
        MacCidToNodeId(cid) << " for Lcid: " << MacCidToLcid(cid) << ", Space left in the Queue: " <<
        queue->getQueueSize() - queue->getByteLength() << "\n";
    }
        /// After bufferization buffers must be synchronized
    assert(mbuf_[cid]->getQueueLength() == macBuffers_[cid]->getQueueLength());
    return true;
}

void LteMacBase::deleteQueues(MacNodeId nodeId)
{
    LteMacBuffers::iterator mit;
    LteMacBufferMap::iterator vit;
    for (mit = mbuf_.begin(); mit != mbuf_.end(); )
    {
        if (MacCidToNodeId(mit->first) == nodeId)
        {
            delete mit->second;        // Delete Queue
            mbuf_.erase(mit++);        // Delete Elem
        } else {
            mit++;
        }
    }
    for (vit = macBuffers_.begin(); vit != macBuffers_.end(); )
    {
        if (MacCidToNodeId(vit->first) == nodeId)
        {
            delete vit->second;        // Delete Queue
            macBuffers_.erase(vit++);        // Delete Elem
        } else {
            vit++;
        }
    }

    // TODO remove traffic descriptor and lcg entry
}


/*
 * Main functions
 */
void LteMacBase::initialize(int stage)
{
    if (stage == 0)
    {
        /* Gates initialization */
        up_[IN] = gate("RLC_to_MAC");
        up_[OUT] = gate("MAC_to_RLC");
        down_[IN] = gate("PHY_to_MAC");
        down_[OUT] = gate("MAC_to_PHY");

        /* Create buffers */
        queueSize_ = par("queueSize");
        maxBytesPerTti_ = par("maxBytesPerTti");

        nodeId_ = getAncestorPar("macNodeId");
        cellId_ = getAncestorPar("macCellId");

        /* Get reference to binder */
        binder_ = getBinder();

        /* Set The MAC MIB */

        muMimo_ = par("muMimo");

        harqProcesses_ = par("harqProcesses");

        /* Start TTI tick */
        ttiTick_ = new cMessage("ttiTick_");
        ttiTick_->setSchedulingPriority(1);        // TTI TICK after other messages
        scheduleAt(NOW + TTI, ttiTick_);
        macBufferOverflowDl_ = registerSignal("macBufferOverflowDl");
        macBufferOverflowUl_ = registerSignal("macBufferOverflowUl");
        receivedPacketFromUpperLayer = registerSignal("receivedPacketFromUpperLayer");
        receivedPacketFromLowerLayer = registerSignal("receivedPacketFromLowerLayer");
        sentPacketToUpperLayer = registerSignal("sentPacketToUpperLayer");
        sentPacketToLowerLayer = registerSignal("sentPacketToLowerLayer");
        tSample_ = new TaggedSample();
        tSample_->module_ = this;

        measuredItbs_ = registerSignal("measuredItbs");
        measuredItbs_lte_ = registerSignal("measuredItbs_lte");
        WATCH(queueSize_);
        WATCH(maxBytesPerTti_);
        WATCH(nodeId_);
        WATCH_MAP(mbuf_);
        WATCH_MAP(macBuffers_);
    }
}

void LteMacBase::handleMessage(cMessage* msg)
{
    if (msg->isSelfMessage())
    {
        handleSelfMessage();
        scheduleAt(NOW + TTI, msg);
        return;
    }

    cPacket* pkt = check_and_cast<cPacket *>(msg);
    EV << "LteMacBase : Received packet " << pkt->getName() <<
    " from port " << pkt->getArrivalGate()->getName() << endl;

    cGate* incoming = pkt->getArrivalGate();

    if (incoming == down_[IN])
    {
        // message from PHY_to_MAC gate (from lower layer)
        emit(receivedPacketFromLowerLayer, pkt);
        fromPhy(pkt);
    }
    else
    {
        // message from RLC_to_MAC gate (from upper layer)
        emit(receivedPacketFromUpperLayer, pkt);
        fromRlc(pkt);
    }
    return;
}

void LteMacBase::finish()
{
    // TODO make-finish
}


/**
 * stealer - https://github.com/zjx20/stealer
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2014 JianXiong Zhou <zhoujianxiong2@gmail.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/*
 * for_each.h
 *
 *  Created on: 2014-11-6
 *      Author: jianxiongzhou
 */

#ifndef PP_FOR_EACH_H_
#define PP_FOR_EACH_H_

#include "select.h"

// std::string SEP() {return ",";}
// std::string DO(size_t i, std::string str) {return "xxx";}
// std::string result = "";
// std::vector<std::string> args = __VA_ARGS__;
// size_t size = args.size();
// for (int i = 1; i <= size; i++) {
//   result += DO(i, args[i]);
//   if (i != size) { result += SEP(); }
// }
#define PP_FOR_EACH(DO, SEP, ...) \
        _PP_FOR_EACH_I(DO, SEP, ##__VA_ARGS__)

#define _PP_FOR_EACH_I(DO, SEP, ...) _PP_FOR_PP_EXPAND(_PP_FOR_PP_EXPAND_CAT(_PP_FOR_EACH_II_, PP_SIZE(__VA_ARGS__))(DO, SEP, __VA_ARGS__,))

// redefine PP_EXPAND() and PP_EXPAND_CAT(), to avoid recursive expanding
#define _PP_FOR_PP_EXPAND(x) x
#define _PP_FOR_PP_CAT(x, y) x##y
#define _PP_FOR_PP_EXPAND_CAT(x, y) _PP_FOR_PP_CAT(x, y)

#define _PP_FOR_EACH_II_0(...)
#define _PP_FOR_EACH_II_1(DO,  SEP, ...) DO(1, PP_SELECT(1,  __VA_ARGS__))
#define _PP_FOR_EACH_II_2(DO,  SEP, ...) _PP_FOR_EACH_II_1(DO,  SEP, __VA_ARGS__) SEP() DO(2,  PP_SELECT(2,  __VA_ARGS__))
#define _PP_FOR_EACH_II_3(DO,  SEP, ...) _PP_FOR_EACH_II_2(DO,  SEP, __VA_ARGS__) SEP() DO(3,  PP_SELECT(3,  __VA_ARGS__))
#define _PP_FOR_EACH_II_4(DO,  SEP, ...) _PP_FOR_EACH_II_3(DO,  SEP, __VA_ARGS__) SEP() DO(4,  PP_SELECT(4,  __VA_ARGS__))
#define _PP_FOR_EACH_II_5(DO,  SEP, ...) _PP_FOR_EACH_II_4(DO,  SEP, __VA_ARGS__) SEP() DO(5,  PP_SELECT(5,  __VA_ARGS__))
#define _PP_FOR_EACH_II_6(DO,  SEP, ...) _PP_FOR_EACH_II_5(DO,  SEP, __VA_ARGS__) SEP() DO(6,  PP_SELECT(6,  __VA_ARGS__))
#define _PP_FOR_EACH_II_7(DO,  SEP, ...) _PP_FOR_EACH_II_6(DO,  SEP, __VA_ARGS__) SEP() DO(7,  PP_SELECT(7,  __VA_ARGS__))
#define _PP_FOR_EACH_II_8(DO,  SEP, ...) _PP_FOR_EACH_II_7(DO,  SEP, __VA_ARGS__) SEP() DO(8,  PP_SELECT(8,  __VA_ARGS__))
#define _PP_FOR_EACH_II_9(DO,  SEP, ...) _PP_FOR_EACH_II_8(DO,  SEP, __VA_ARGS__) SEP() DO(9,  PP_SELECT(9,  __VA_ARGS__))
#define _PP_FOR_EACH_II_10(DO, SEP, ...) _PP_FOR_EACH_II_9(DO,  SEP, __VA_ARGS__) SEP() DO(10, PP_SELECT(10, __VA_ARGS__))
#define _PP_FOR_EACH_II_11(DO, SEP, ...) _PP_FOR_EACH_II_10(DO, SEP, __VA_ARGS__) SEP() DO(11, PP_SELECT(11, __VA_ARGS__))
#define _PP_FOR_EACH_II_12(DO, SEP, ...) _PP_FOR_EACH_II_11(DO, SEP, __VA_ARGS__) SEP() DO(12, PP_SELECT(12, __VA_ARGS__))
#define _PP_FOR_EACH_II_13(DO, SEP, ...) _PP_FOR_EACH_II_12(DO, SEP, __VA_ARGS__) SEP() DO(13, PP_SELECT(13, __VA_ARGS__))
#define _PP_FOR_EACH_II_14(DO, SEP, ...) _PP_FOR_EACH_II_13(DO, SEP, __VA_ARGS__) SEP() DO(14, PP_SELECT(14, __VA_ARGS__))
#define _PP_FOR_EACH_II_15(DO, SEP, ...) _PP_FOR_EACH_II_14(DO, SEP, __VA_ARGS__) SEP() DO(15, PP_SELECT(15, __VA_ARGS__))
#define _PP_FOR_EACH_II_16(DO, SEP, ...) _PP_FOR_EACH_II_15(DO, SEP, __VA_ARGS__) SEP() DO(16, PP_SELECT(16, __VA_ARGS__))
#define _PP_FOR_EACH_II_17(DO, SEP, ...) _PP_FOR_EACH_II_16(DO, SEP, __VA_ARGS__) SEP() DO(17, PP_SELECT(17, __VA_ARGS__))
#define _PP_FOR_EACH_II_18(DO, SEP, ...) _PP_FOR_EACH_II_17(DO, SEP, __VA_ARGS__) SEP() DO(18, PP_SELECT(18, __VA_ARGS__))
#define _PP_FOR_EACH_II_19(DO, SEP, ...) _PP_FOR_EACH_II_18(DO, SEP, __VA_ARGS__) SEP() DO(19, PP_SELECT(19, __VA_ARGS__))
#define _PP_FOR_EACH_II_20(DO, SEP, ...) _PP_FOR_EACH_II_19(DO, SEP, __VA_ARGS__) SEP() DO(20, PP_SELECT(20, __VA_ARGS__))
#define _PP_FOR_EACH_II_21(DO, SEP, ...) _PP_FOR_EACH_II_20(DO, SEP, __VA_ARGS__) SEP() DO(21, PP_SELECT(21, __VA_ARGS__))
#define _PP_FOR_EACH_II_22(DO, SEP, ...) _PP_FOR_EACH_II_21(DO, SEP, __VA_ARGS__) SEP() DO(22, PP_SELECT(22, __VA_ARGS__))
#define _PP_FOR_EACH_II_23(DO, SEP, ...) _PP_FOR_EACH_II_22(DO, SEP, __VA_ARGS__) SEP() DO(23, PP_SELECT(23, __VA_ARGS__))
#define _PP_FOR_EACH_II_24(DO, SEP, ...) _PP_FOR_EACH_II_23(DO, SEP, __VA_ARGS__) SEP() DO(24, PP_SELECT(24, __VA_ARGS__))
#define _PP_FOR_EACH_II_25(DO, SEP, ...) _PP_FOR_EACH_II_24(DO, SEP, __VA_ARGS__) SEP() DO(25, PP_SELECT(25, __VA_ARGS__))
#define _PP_FOR_EACH_II_26(DO, SEP, ...) _PP_FOR_EACH_II_25(DO, SEP, __VA_ARGS__) SEP() DO(26, PP_SELECT(26, __VA_ARGS__))
#define _PP_FOR_EACH_II_27(DO, SEP, ...) _PP_FOR_EACH_II_26(DO, SEP, __VA_ARGS__) SEP() DO(27, PP_SELECT(27, __VA_ARGS__))
#define _PP_FOR_EACH_II_28(DO, SEP, ...) _PP_FOR_EACH_II_27(DO, SEP, __VA_ARGS__) SEP() DO(28, PP_SELECT(28, __VA_ARGS__))
#define _PP_FOR_EACH_II_29(DO, SEP, ...) _PP_FOR_EACH_II_28(DO, SEP, __VA_ARGS__) SEP() DO(29, PP_SELECT(29, __VA_ARGS__))
#define _PP_FOR_EACH_II_30(DO, SEP, ...) _PP_FOR_EACH_II_29(DO, SEP, __VA_ARGS__) SEP() DO(30, PP_SELECT(30, __VA_ARGS__))
#define _PP_FOR_EACH_II_31(DO, SEP, ...) _PP_FOR_EACH_II_30(DO, SEP, __VA_ARGS__) SEP() DO(31, PP_SELECT(31, __VA_ARGS__))
#define _PP_FOR_EACH_II_32(DO, SEP, ...) _PP_FOR_EACH_II_31(DO, SEP, __VA_ARGS__) SEP() DO(32, PP_SELECT(32, __VA_ARGS__))
#define _PP_FOR_EACH_II_33(DO, SEP, ...) _PP_FOR_EACH_II_32(DO, SEP, __VA_ARGS__) SEP() DO(33, PP_SELECT(33, __VA_ARGS__))
#define _PP_FOR_EACH_II_34(DO, SEP, ...) _PP_FOR_EACH_II_33(DO, SEP, __VA_ARGS__) SEP() DO(34, PP_SELECT(34, __VA_ARGS__))
#define _PP_FOR_EACH_II_35(DO, SEP, ...) _PP_FOR_EACH_II_34(DO, SEP, __VA_ARGS__) SEP() DO(35, PP_SELECT(35, __VA_ARGS__))
#define _PP_FOR_EACH_II_36(DO, SEP, ...) _PP_FOR_EACH_II_35(DO, SEP, __VA_ARGS__) SEP() DO(36, PP_SELECT(36, __VA_ARGS__))
#define _PP_FOR_EACH_II_37(DO, SEP, ...) _PP_FOR_EACH_II_36(DO, SEP, __VA_ARGS__) SEP() DO(37, PP_SELECT(37, __VA_ARGS__))
#define _PP_FOR_EACH_II_38(DO, SEP, ...) _PP_FOR_EACH_II_37(DO, SEP, __VA_ARGS__) SEP() DO(38, PP_SELECT(38, __VA_ARGS__))
#define _PP_FOR_EACH_II_39(DO, SEP, ...) _PP_FOR_EACH_II_38(DO, SEP, __VA_ARGS__) SEP() DO(39, PP_SELECT(39, __VA_ARGS__))
#define _PP_FOR_EACH_II_40(DO, SEP, ...) _PP_FOR_EACH_II_39(DO, SEP, __VA_ARGS__) SEP() DO(40, PP_SELECT(40, __VA_ARGS__))
#define _PP_FOR_EACH_II_41(DO, SEP, ...) _PP_FOR_EACH_II_40(DO, SEP, __VA_ARGS__) SEP() DO(41, PP_SELECT(41, __VA_ARGS__))
#define _PP_FOR_EACH_II_42(DO, SEP, ...) _PP_FOR_EACH_II_41(DO, SEP, __VA_ARGS__) SEP() DO(42, PP_SELECT(42, __VA_ARGS__))
#define _PP_FOR_EACH_II_43(DO, SEP, ...) _PP_FOR_EACH_II_42(DO, SEP, __VA_ARGS__) SEP() DO(43, PP_SELECT(43, __VA_ARGS__))
#define _PP_FOR_EACH_II_44(DO, SEP, ...) _PP_FOR_EACH_II_43(DO, SEP, __VA_ARGS__) SEP() DO(44, PP_SELECT(44, __VA_ARGS__))
#define _PP_FOR_EACH_II_45(DO, SEP, ...) _PP_FOR_EACH_II_44(DO, SEP, __VA_ARGS__) SEP() DO(45, PP_SELECT(45, __VA_ARGS__))
#define _PP_FOR_EACH_II_46(DO, SEP, ...) _PP_FOR_EACH_II_45(DO, SEP, __VA_ARGS__) SEP() DO(46, PP_SELECT(46, __VA_ARGS__))
#define _PP_FOR_EACH_II_47(DO, SEP, ...) _PP_FOR_EACH_II_46(DO, SEP, __VA_ARGS__) SEP() DO(47, PP_SELECT(47, __VA_ARGS__))
#define _PP_FOR_EACH_II_48(DO, SEP, ...) _PP_FOR_EACH_II_47(DO, SEP, __VA_ARGS__) SEP() DO(48, PP_SELECT(48, __VA_ARGS__))
#define _PP_FOR_EACH_II_49(DO, SEP, ...) _PP_FOR_EACH_II_48(DO, SEP, __VA_ARGS__) SEP() DO(49, PP_SELECT(49, __VA_ARGS__))
#define _PP_FOR_EACH_II_50(DO, SEP, ...) _PP_FOR_EACH_II_49(DO, SEP, __VA_ARGS__) SEP() DO(50, PP_SELECT(50, __VA_ARGS__))
#define _PP_FOR_EACH_II_51(DO, SEP, ...) _PP_FOR_EACH_II_50(DO, SEP, __VA_ARGS__) SEP() DO(51, PP_SELECT(51, __VA_ARGS__))
#define _PP_FOR_EACH_II_52(DO, SEP, ...) _PP_FOR_EACH_II_51(DO, SEP, __VA_ARGS__) SEP() DO(52, PP_SELECT(52, __VA_ARGS__))
#define _PP_FOR_EACH_II_53(DO, SEP, ...) _PP_FOR_EACH_II_52(DO, SEP, __VA_ARGS__) SEP() DO(53, PP_SELECT(53, __VA_ARGS__))
#define _PP_FOR_EACH_II_54(DO, SEP, ...) _PP_FOR_EACH_II_53(DO, SEP, __VA_ARGS__) SEP() DO(54, PP_SELECT(54, __VA_ARGS__))
#define _PP_FOR_EACH_II_55(DO, SEP, ...) _PP_FOR_EACH_II_54(DO, SEP, __VA_ARGS__) SEP() DO(55, PP_SELECT(55, __VA_ARGS__))
#define _PP_FOR_EACH_II_56(DO, SEP, ...) _PP_FOR_EACH_II_55(DO, SEP, __VA_ARGS__) SEP() DO(56, PP_SELECT(56, __VA_ARGS__))
#define _PP_FOR_EACH_II_57(DO, SEP, ...) _PP_FOR_EACH_II_56(DO, SEP, __VA_ARGS__) SEP() DO(57, PP_SELECT(57, __VA_ARGS__))
#define _PP_FOR_EACH_II_58(DO, SEP, ...) _PP_FOR_EACH_II_57(DO, SEP, __VA_ARGS__) SEP() DO(58, PP_SELECT(58, __VA_ARGS__))
#define _PP_FOR_EACH_II_59(DO, SEP, ...) _PP_FOR_EACH_II_58(DO, SEP, __VA_ARGS__) SEP() DO(59, PP_SELECT(59, __VA_ARGS__))
#define _PP_FOR_EACH_II_60(DO, SEP, ...) _PP_FOR_EACH_II_59(DO, SEP, __VA_ARGS__) SEP() DO(60, PP_SELECT(60, __VA_ARGS__))
#define _PP_FOR_EACH_II_61(DO, SEP, ...) _PP_FOR_EACH_II_60(DO, SEP, __VA_ARGS__) SEP() DO(61, PP_SELECT(61, __VA_ARGS__))
#define _PP_FOR_EACH_II_62(DO, SEP, ...) _PP_FOR_EACH_II_61(DO, SEP, __VA_ARGS__) SEP() DO(62, PP_SELECT(62, __VA_ARGS__))
#define _PP_FOR_EACH_II_63(DO, SEP, ...) _PP_FOR_EACH_II_62(DO, SEP, __VA_ARGS__) SEP() DO(63, PP_SELECT(63, __VA_ARGS__))
#define _PP_FOR_EACH_II_64(DO, SEP, ...) _PP_FOR_EACH_II_63(DO, SEP, __VA_ARGS__) SEP() DO(64, PP_SELECT(64, __VA_ARGS__))

#endif /* PP_FOR_EACH_H_ */


/* ----------------------------------------------------------------------
   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
   http://lammps.sandia.gov, Sandia National Laboratories
   Steve Plimpton, sjplimp@sandia.gov

   Copyright (2003) Sandia Corporation.  Under the terms of Contract
   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
   certain rights in this software.  This software is distributed under
   the GNU General Public License.

   See the README file in the top-level LAMMPS directory.
------------------------------------------------------------------------- */

/* ----------------------------------------------------------------------
   Contributing authors: Tim Lau (MIT)
------------------------------------------------------------------------- */

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include "pair_eam_fs_cuda.h"
#include "atom.h"
#include "comm.h"
#include "memory.h"
#include "error.h"

using namespace LAMMPS_NS;

#define MAXLINE 1024

/* ---------------------------------------------------------------------- */

PairEAMFSCuda::PairEAMFSCuda(LAMMPS *lmp) : PairEAMCuda(lmp)
{
  cuda = lmp->cuda;
   if(cuda == NULL)
        error->all(FLERR,"You cannot use a /cuda class, without activating 'cuda' acceleration. Provide '-c on' as command-line argument to LAMMPS..");

  one_coeff = 1;
}

/* ----------------------------------------------------------------------
   set coeffs for one or more type pairs
   read EAM Finnis-Sinclair file
------------------------------------------------------------------------- */

void PairEAMFSCuda::coeff(int narg, char **arg)
{
  int i,j;

  if (!allocated) allocate();

  if (narg != 3 + atom->ntypes)
    error->all(FLERR,"Incorrect args for pair coefficients");

  // insure I,J args are * *

  if (strcmp(arg[0],"*") != 0 || strcmp(arg[1],"*") != 0)
    error->all(FLERR,"Incorrect args for pair coefficients");

  // read EAM Finnis-Sinclair file

  if (fs) {
    for (i = 0; i < fs->nelements; i++) delete [] fs->elements[i];
    delete [] fs->elements;
    delete [] fs->mass;
    memory->destroy(fs->frho);
    memory->destroy(fs->rhor);
    memory->destroy(fs->z2r);
    delete fs;
  }
  fs = new Fs();
  read_file(arg[2]);

  // read args that map atom types to elements in potential file
  // map[i] = which element the Ith atom type is, -1 if NULL

  for (i = 3; i < narg; i++) {
    if (strcmp(arg[i],"NULL") == 0) {
      map[i-2] = -1;
      continue;
    }
    for (j = 0; j < fs->nelements; j++)
      if (strcmp(arg[i],fs->elements[j]) == 0) break;
    if (j < fs->nelements) map[i-2] = j;
    else error->all(FLERR,"No matching element in EAM potential file");
  }

  // clear setflag since coeff() called once with I,J = * *

  int n = atom->ntypes;
  for (i = 1; i <= n; i++)
    for (j = i; j <= n; j++)
      setflag[i][j] = 0;

  // set setflag i,j for type pairs where both are mapped to elements
  // set mass of atom type if i = j

  int count = 0;
  for (i = 1; i <= n; i++) {
    for (j = i; j <= n; j++) {
      if (map[i] >= 0 && map[j] >= 0) {
        setflag[i][j] = 1;
        if (i == j) atom->set_mass(i,fs->mass[map[i]]);
        count++;
      }
    }
  }

  if (count == 0) error->all(FLERR,"Incorrect args for pair coefficients");
}

/* ----------------------------------------------------------------------
   read a multi-element DYNAMO setfl file
------------------------------------------------------------------------- */

void PairEAMFSCuda::read_file(char *filename)
{
  Fs *file = fs;

  // open potential file

  int me = comm->me;
  FILE *fptr;
  char line[MAXLINE];

  if (me == 0) {
    fptr = fopen(filename,"r");
    if (fptr == NULL) {
      char str[128];
      sprintf(str,"Cannot open EAM potential file %s",filename);
      error->one(FLERR,str);
    }
  }

  // read and broadcast header
  // extract element names from nelements line

  int n;
  if (me == 0) {
    fgets(line,MAXLINE,fptr);
    fgets(line,MAXLINE,fptr);
    fgets(line,MAXLINE,fptr);
    fgets(line,MAXLINE,fptr);
    n = strlen(line) + 1;
  }
  MPI_Bcast(&n,1,MPI_INT,0,world);
  MPI_Bcast(line,n,MPI_CHAR,0,world);

  sscanf(line,"%d",&file->nelements);
  int nwords = atom->count_words(line);
  if (nwords != file->nelements + 1)
    error->all(FLERR,"Incorrect element names in EAM potential file");

  char **words = new char*[file->nelements+1];
  nwords = 0;
  strtok(line," \t\n\r\f");
  while ((words[nwords++] = strtok(NULL," \t\n\r\f"))) continue;

  file->elements = new char*[file->nelements];
  for (int i = 0; i < file->nelements; i++) {
    n = strlen(words[i]) + 1;
    file->elements[i] = new char[n];
    strcpy(file->elements[i],words[i]);
  }
  delete [] words;

  if (me == 0) {
    fgets(line,MAXLINE,fptr);
    sscanf(line,"%d %lg %d %lg %lg",
           &file->nrho,&file->drho,&file->nr,&file->dr,&file->cut);
  }

  MPI_Bcast(&file->nrho,1,MPI_INT,0,world);
  MPI_Bcast(&file->drho,1,MPI_DOUBLE,0,world);
  MPI_Bcast(&file->nr,1,MPI_INT,0,world);
  MPI_Bcast(&file->dr,1,MPI_DOUBLE,0,world);
  MPI_Bcast(&file->cut,1,MPI_DOUBLE,0,world);

  file->mass = new double[file->nelements];
  memory->create(file->frho,file->nelements,file->nrho+1,
                                              "pair:frho");
  memory->create(file->rhor,file->nelements,file->nelements,
                 file->nr+1,"pair:rhor");
  memory->create(file->z2r,file->nelements,file->nelements,
                 file->nr+1,"pair:z2r");
  int i,j,tmp;
  for (i = 0; i < file->nelements; i++) {
    if (me == 0) {
      fgets(line,MAXLINE,fptr);
      sscanf(line,"%d %lg",&tmp,&file->mass[i]);
    }
    MPI_Bcast(&file->mass[i],1,MPI_DOUBLE,0,world);

    if (me == 0) grab(fptr,file->nrho,&file->frho[i][1]);
    MPI_Bcast(&file->frho[i][1],file->nrho,MPI_DOUBLE,0,world);

    for (j = 0; j < file->nelements; j++) {
      if (me == 0) grab(fptr,file->nr,&file->rhor[i][j][1]);
      MPI_Bcast(&file->rhor[i][j][1],file->nr,MPI_DOUBLE,0,world);
    }
  }

  for (i = 0; i < file->nelements; i++)
    for (j = 0; j <= i; j++) {
      if (me == 0) grab(fptr,file->nr,&file->z2r[i][j][1]);
      MPI_Bcast(&file->z2r[i][j][1],file->nr,MPI_DOUBLE,0,world);
    }

  // close the potential file

  if (me == 0) fclose(fptr);
}

/* ----------------------------------------------------------------------
   copy read-in setfl potential to standard array format
------------------------------------------------------------------------- */

void PairEAMFSCuda::file2array()
{
  int i,j,m,n;
  int ntypes = atom->ntypes;

  // set function params directly from fs file

  nrho = fs->nrho;
  nr = fs->nr;
  drho = fs->drho;
  dr = fs->dr;

  // ------------------------------------------------------------------
  // setup frho arrays
  // ------------------------------------------------------------------

  // allocate frho arrays
  // nfrho = # of fs elements + 1 for zero array

  nfrho = fs->nelements + 1;
  memory->destroy(frho);
  memory->create(frho,nfrho,nrho+1,"pair:frho");

  // copy each element's frho to global frho

  for (i = 0; i < fs->nelements; i++)
    for (m = 1; m <= nrho; m++) frho[i][m] = fs->frho[i][m];

  // add extra frho of zeroes for non-EAM types to point to (pair hybrid)
  // this is necessary b/c fp is still computed for non-EAM atoms

  for (m = 1; m <= nrho; m++) frho[nfrho-1][m] = 0.0;

  // type2frho[i] = which frho array (0 to nfrho-1) each atom type maps to
  // if atom type doesn't point to element (non-EAM atom in pair hybrid)
  // then map it to last frho array of zeroes

  for (i = 1; i <= ntypes; i++)
    if (map[i] >= 0) type2frho[i] = map[i];
    else type2frho[i] = nfrho-1;

  // ------------------------------------------------------------------
  // setup rhor arrays
  // ------------------------------------------------------------------

  // allocate rhor arrays
  // nrhor = square of # of fs elements

  nrhor = fs->nelements * fs->nelements;
  memory->destroy(rhor);
  memory->create(rhor,nrhor,nr+1,"pair:rhor");

  // copy each element pair rhor to global rhor

  n = 0;
  for (i = 0; i < fs->nelements; i++)
    for (j = 0; j < fs->nelements; j++) {
      for (m = 1; m <= nr; m++) rhor[n][m] = fs->rhor[i][j][m];
      n++;
    }

  // type2rhor[i][j] = which rhor array (0 to nrhor-1) each type pair maps to
  // for fs files, there is a full NxN set of rhor arrays
  // OK if map = -1 (non-EAM atom in pair hybrid) b/c type2rhor not used

  for (i = 1; i <= ntypes; i++)
    for (j = 1; j <= ntypes; j++)
      type2rhor[i][j] = map[i] * fs->nelements + map[j];

  // ------------------------------------------------------------------
  // setup z2r arrays
  // ------------------------------------------------------------------

  // allocate z2r arrays
  // nz2r = N*(N+1)/2 where N = # of fs elements

  nz2r = fs->nelements * (fs->nelements+1) / 2;
  memory->destroy(z2r);
  memory->create(z2r,nz2r,nr+1,"pair:z2r");

  // copy each element pair z2r to global z2r, only for I >= J

  n = 0;
  for (i = 0; i < fs->nelements; i++)
    for (j = 0; j <= i; j++) {
      for (m = 1; m <= nr; m++) z2r[n][m] = fs->z2r[i][j][m];
      n++;
    }

  // type2z2r[i][j] = which z2r array (0 to nz2r-1) each type pair maps to
  // set of z2r arrays only fill lower triangular Nelement matrix
  // value = n = sum over rows of lower-triangular matrix until reach irow,icol
  // swap indices when irow < icol to stay lower triangular
  // if map = -1 (non-EAM atom in pair hybrid):
  //   type2z2r is not used by non-opt
  //   but set type2z2r to 0 since accessed by opt

  int irow,icol;
  for (i = 1; i <= ntypes; i++) {
    for (j = 1; j <= ntypes; j++) {
      irow = map[i];
      icol = map[j];
      if (irow == -1 || icol == -1) {
        type2z2r[i][j] = 0;
        continue;
      }
      if (irow < icol) {
        irow = map[j];
        icol = map[i];
      }
      n = 0;
      for (m = 0; m < irow; m++) n += m + 1;
      n += icol;
      type2z2r[i][j] = n;
    }
  }
}

// Copyright (c) 2009-2010 Satoshi Nakamoto
// Copyright (c) 2009-2012 The Bitcoin developers
// Copyright (c) 2013 The NovaCoin developers
// Distributed under the MIT/X11 software license, see the accompanying
// file COPYING or http://www.opensource.org/licenses/mit-license.php.

#include "txdb.h"
#include "miner.h"
#include "kernel.h"

using namespace std;

//////////////////////////////////////////////////////////////////////////////
//
// BitcoinMiner
//

extern unsigned int nMinerSleep;

int static FormatHashBlocks(void* pbuffer, unsigned int len)
{
    unsigned char* pdata = (unsigned char*)pbuffer;
    unsigned int blocks = 1 + ((len + 8) / 64);
    unsigned char* pend = pdata + 64 * blocks;
    memset(pdata + len, 0, 64 * blocks - len);
    pdata[len] = 0x80;
    unsigned int bits = len * 8;
    pend[-1] = (bits >> 0) & 0xff;
    pend[-2] = (bits >> 8) & 0xff;
    pend[-3] = (bits >> 16) & 0xff;
    pend[-4] = (bits >> 24) & 0xff;
    return blocks;
}

static const unsigned int pSHA256InitState[8] =
{0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19};

void SHA256Transform(void* pstate, void* pinput, const void* pinit)
{
    SHA256_CTX ctx;
    unsigned char data[64];

    SHA256_Init(&ctx);

    for (int i = 0; i < 16; i++)
        ((uint32_t*)data)[i] = ByteReverse(((uint32_t*)pinput)[i]);

    for (int i = 0; i < 8; i++)
        ctx.h[i] = ((uint32_t*)pinit)[i];

    SHA256_Update(&ctx, data, sizeof(data));
    for (int i = 0; i < 8; i++)
        ((uint32_t*)pstate)[i] = ctx.h[i];
}

// Some explaining would be appreciated
class COrphan
{
public:
    CTransaction* ptx;
    set<uint256> setDependsOn;
    double dPriority;
    double dFeePerKb;

    COrphan(CTransaction* ptxIn)
    {
        ptx = ptxIn;
        dPriority = dFeePerKb = 0;
    }

    void print() const
    {
        printf("COrphan(hash=%s, dPriority=%.1f, dFeePerKb=%.1f)\n",
               ptx->GetHash().ToString().substr(0,10).c_str(), dPriority, dFeePerKb);
        BOOST_FOREACH(uint256 hash, setDependsOn)
            printf("   setDependsOn %s\n", hash.ToString().substr(0,10).c_str());
    }
};


uint64_t nLastBlockTx = 0;
uint64_t nLastBlockSize = 0;
int64_t nLastCoinStakeSearchInterval = 0;

// We want to sort transactions by priority and fee, so:
typedef boost::tuple<double, double, CTransaction*> TxPriority;
class TxPriorityCompare
{
    bool byFee;
public:
    TxPriorityCompare(bool _byFee) : byFee(_byFee) { }
    bool operator()(const TxPriority& a, const TxPriority& b)
    {
        if (byFee)
        {
            if (a.get<1>() == b.get<1>())
                return a.get<0>() < b.get<0>();
            return a.get<1>() < b.get<1>();
        }
        else
        {
            if (a.get<0>() == b.get<0>())
                return a.get<1>() < b.get<1>();
            return a.get<0>() < b.get<0>();
        }
    }
};

// CreateNewBlock: create new block (without proof-of-work/proof-of-stake)
CBlock* CreateNewBlock(CWallet* pwallet, bool fProofOfStake, int64_t* pFees)
{
    // Create new block
    auto_ptr<CBlock> pblock(new CBlock());
    if (!pblock.get())
        return NULL;

    CBlockIndex* pindexPrev = pindexBest;
    // Create coinbase tx
    CTransaction txNew;
    txNew.vin.resize(1);
    txNew.vin[0].prevout.SetNull();
    txNew.vout.resize(1);

    int nHeight = pindexPrev->nHeight+1; // height of new block

    if (!fProofOfStake)
    {
        CReserveKey reservekey(pwallet);
        CPubKey pubkey;
        if (!reservekey.GetReservedKey(pubkey))
            return NULL;
        txNew.vout[0].scriptPubKey.SetDestination(pubkey.GetID());
    }
    else
    {
        // Height first in coinbase required for block.version=2
        txNew.vin[0].scriptSig = (CScript() << nHeight) + COINBASE_FLAGS;
        assert(txNew.vin[0].scriptSig.size() <= 100);

        txNew.vout[0].SetEmpty();
    }

    // Add our coinbase tx as first transaction
    pblock->vtx.push_back(txNew);

    // Largest block you're willing to create:
    unsigned int nBlockMaxSize = GetArg("-blockmaxsize", MAX_BLOCK_SIZE_GEN/2);
    // Limit to betweeen 1K and MAX_BLOCK_SIZE-1K for sanity:
    nBlockMaxSize = std::max((unsigned int)1000, std::min((unsigned int)(MAX_BLOCK_SIZE-1000), nBlockMaxSize));

    // How much of the block should be dedicated to high-priority transactions,
    // included regardless of the fees they pay
    unsigned int nBlockPrioritySize = GetArg("-blockprioritysize", 27000);
    nBlockPrioritySize = std::min(nBlockMaxSize, nBlockPrioritySize);

    // Minimum block size you want to create; block will be filled with free transactions
    // until there are no more or the block reaches this size:
    unsigned int nBlockMinSize = GetArg("-blockminsize", 0);
    nBlockMinSize = std::min(nBlockMaxSize, nBlockMinSize);

    // Fee-per-kilobyte amount considered the same as "free"
    // Be careful setting this: if you set it to zero then
    // a transaction spammer can cheaply fill blocks using
    // 1-satoshi-fee transactions. It should be set above the real
    // cost to you of processing a transaction.
    int64_t nMinTxFee = MIN_TX_FEE;
    if (mapArgs.count("-mintxfee"))
        ParseMoney(mapArgs["-mintxfee"], nMinTxFee);

    pblock->nBits = GetNextTargetRequired(pindexPrev, fProofOfStake);

    // Collect memory pool transactions into the block
    int64_t nFees = 0;
    {
        LOCK2(cs_main, mempool.cs);
        CTxDB txdb("r");

        // Priority order to process transactions
        list<COrphan> vOrphan; // list memory doesn't move
        map<uint256, vector<COrphan*> > mapDependers;

        // This vector will be sorted into a priority queue:
        vector<TxPriority> vecPriority;
        vecPriority.reserve(mempool.mapTx.size());
        for (map<uint256, CTransaction>::iterator mi = mempool.mapTx.begin(); mi != mempool.mapTx.end(); ++mi)
        {
            CTransaction& tx = (*mi).second;
            if (tx.IsCoinBase() || tx.IsCoinStake() || !tx.IsFinal())
                continue;

            COrphan* porphan = NULL;
            double dPriority = 0;
            int64_t nTotalIn = 0;
            bool fMissingInputs = false;
            BOOST_FOREACH(const CTxIn& txin, tx.vin)
            {
                // Read prev transaction
                CTransaction txPrev;
                CTxIndex txindex;
                if (!txPrev.ReadFromDisk(txdb, txin.prevout, txindex))
                {
                    // This should never happen; all transactions in the memory
                    // pool should connect to either transactions in the chain
                    // or other transactions in the memory pool.
                    if (!mempool.mapTx.count(txin.prevout.hash))
                    {
                        printf("ERROR: mempool transaction missing input\n");
                        if (fDebug) assert("mempool transaction missing input" == 0);
                        fMissingInputs = true;
                        if (porphan)
                            vOrphan.pop_back();
                        break;
                    }

                    // Has to wait for dependencies
                    if (!porphan)
                    {
                        // Use list for automatic deletion
                        vOrphan.push_back(COrphan(&tx));
                        porphan = &vOrphan.back();
                    }
                    mapDependers[txin.prevout.hash].push_back(porphan);
                    porphan->setDependsOn.insert(txin.prevout.hash);
                    nTotalIn += mempool.mapTx[txin.prevout.hash].vout[txin.prevout.n].nValue;
                    continue;
                }
                int64_t nValueIn = txPrev.vout[txin.prevout.n].nValue;
                nTotalIn += nValueIn;

                int nConf = txindex.GetDepthInMainChain();
                dPriority += (double)nValueIn * nConf;
            }
            if (fMissingInputs) continue;

            // Priority is sum(valuein * age) / txsize
            unsigned int nTxSize = ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION);
            dPriority /= nTxSize;

            // This is a more accurate fee-per-kilobyte than is used by the client code, because the
            // client code rounds up the size to the nearest 1K. That's good, because it gives an
            // incentive to create smaller transactions.
            double dFeePerKb =  double(nTotalIn-tx.GetValueOut()) / (double(nTxSize)/1000.0);

            if (porphan)
            {
                porphan->dPriority = dPriority;
                porphan->dFeePerKb = dFeePerKb;
            }
            else
                vecPriority.push_back(TxPriority(dPriority, dFeePerKb, &(*mi).second));
        }

        // Collect transactions into block
        map<uint256, CTxIndex> mapTestPool;
        uint64_t nBlockSize = 1000;
        uint64_t nBlockTx = 0;
        int nBlockSigOps = 100;
        bool fSortedByFee = (nBlockPrioritySize <= 0);

        TxPriorityCompare comparer(fSortedByFee);
        std::make_heap(vecPriority.begin(), vecPriority.end(), comparer);

        while (!vecPriority.empty())
        {
            // Take highest priority transaction off the priority queue:
            double dPriority = vecPriority.front().get<0>();
            double dFeePerKb = vecPriority.front().get<1>();
            CTransaction& tx = *(vecPriority.front().get<2>());

            std::pop_heap(vecPriority.begin(), vecPriority.end(), comparer);
            vecPriority.pop_back();

            // Size limits
            unsigned int nTxSize = ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION);
            if (nBlockSize + nTxSize >= nBlockMaxSize)
                continue;

            // Legacy limits on sigOps:
            unsigned int nTxSigOps = tx.GetLegacySigOpCount();
            if (nBlockSigOps + nTxSigOps >= MAX_BLOCK_SIGOPS)
                continue;

            // Timestamp limit
            if (tx.nTime > GetAdjustedTime() || (fProofOfStake && tx.nTime > pblock->vtx[0].nTime))
                continue;

            // Transaction fee
            int64_t nMinFee = tx.GetMinFee(nBlockSize, GMF_BLOCK);

            // Skip free transactions if we're past the minimum block size:
            if (fSortedByFee && (dFeePerKb < nMinTxFee) && (nBlockSize + nTxSize >= nBlockMinSize))
                continue;

            // Prioritize by fee once past the priority size or we run out of high-priority
            // transactions:
            if (!fSortedByFee &&
                ((nBlockSize + nTxSize >= nBlockPrioritySize) || (dPriority < COIN * 144 / 250)))
            {
                fSortedByFee = true;
                comparer = TxPriorityCompare(fSortedByFee);
                std::make_heap(vecPriority.begin(), vecPriority.end(), comparer);
            }

            // Connecting shouldn't fail due to dependency on other memory pool transactions
            // because we're already processing them in order of dependency
            map<uint256, CTxIndex> mapTestPoolTmp(mapTestPool);
            MapPrevTx mapInputs;
            bool fInvalid;
            if (!tx.FetchInputs(txdb, mapTestPoolTmp, false, true, mapInputs, fInvalid))
                continue;

            int64_t nTxFees = tx.GetValueIn(mapInputs)-tx.GetValueOut();
            if (nTxFees < nMinFee)
                continue;

            nTxSigOps += tx.GetP2SHSigOpCount(mapInputs);
            if (nBlockSigOps + nTxSigOps >= MAX_BLOCK_SIGOPS)
                continue;

            if (!tx.ConnectInputs(txdb, mapInputs, mapTestPoolTmp, CDiskTxPos(1,1,1), pindexPrev, false, true))
                continue;
            mapTestPoolTmp[tx.GetHash()] = CTxIndex(CDiskTxPos(1,1,1), tx.vout.size());
            swap(mapTestPool, mapTestPoolTmp);

            // Added
            pblock->vtx.push_back(tx);
            nBlockSize += nTxSize;
            ++nBlockTx;
            nBlockSigOps += nTxSigOps;
            nFees += nTxFees;

            if (fDebug && GetBoolArg("-printpriority"))
            {
                printf("priority %.1f feeperkb %.1f txid %s\n",
                       dPriority, dFeePerKb, tx.GetHash().ToString().c_str());
            }

            // Add transactions that depend on this one to the priority queue
            uint256 hash = tx.GetHash();
            if (mapDependers.count(hash))
            {
                BOOST_FOREACH(COrphan* porphan, mapDependers[hash])
                {
                    if (!porphan->setDependsOn.empty())
                    {
                        porphan->setDependsOn.erase(hash);
                        if (porphan->setDependsOn.empty())
                        {
                            vecPriority.push_back(TxPriority(porphan->dPriority, porphan->dFeePerKb, porphan->ptx));
                            std::push_heap(vecPriority.begin(), vecPriority.end(), comparer);
                        }
                    }
                }
            }
        }

        nLastBlockTx = nBlockTx;
        nLastBlockSize = nBlockSize;

        if (fDebug && GetBoolArg("-printpriority"))
            printf("CreateNewBlock(): total size %"PRIu64"\n", nBlockSize);

        if (!fProofOfStake)
            pblock->vtx[0].vout[0].nValue = GetProofOfWorkReward(nHeight, nFees);

        if (pFees)
            *pFees = nFees;

        // Fill in header
        pblock->hashPrevBlock  = pindexPrev->GetBlockHash();
        pblock->nTime          = max(pindexPrev->GetPastTimeLimit()+1, pblock->GetMaxTransactionTime());
        pblock->nTime          = max(pblock->GetBlockTime(), PastDrift(pindexPrev->GetBlockTime()));
        if (!fProofOfStake)
            pblock->UpdateTime(pindexPrev);
        pblock->nNonce         = 0;
    }

    return pblock.release();
}


void IncrementExtraNonce(CBlock* pblock, CBlockIndex* pindexPrev, unsigned int& nExtraNonce)
{
    // Update nExtraNonce
    static uint256 hashPrevBlock;
    if (hashPrevBlock != pblock->hashPrevBlock)
    {
        nExtraNonce = 0;
        hashPrevBlock = pblock->hashPrevBlock;
    }
    ++nExtraNonce;

    unsigned int nHeight = pindexPrev->nHeight+1; // Height first in coinbase required for block.version=2
    pblock->vtx[0].vin[0].scriptSig = (CScript() << nHeight << CBigNum(nExtraNonce)) + COINBASE_FLAGS;
    assert(pblock->vtx[0].vin[0].scriptSig.size() <= 100);

    pblock->hashMerkleRoot = pblock->BuildMerkleTree();
}


void FormatHashBuffers(CBlock* pblock, char* pmidstate, char* pdata, char* phash1)
{
    //
    // Pre-build hash buffers
    //
    struct
    {
        struct unnamed2
        {
            int nVersion;
            uint256 hashPrevBlock;
            uint256 hashMerkleRoot;
            unsigned int nTime;
            unsigned int nBits;
            unsigned int nNonce;
        }
        block;
        unsigned char pchPadding0[64];
        uint256 hash1;
        unsigned char pchPadding1[64];
    }
    tmp;
    memset(&tmp, 0, sizeof(tmp));

    tmp.block.nVersion       = pblock->nVersion;
    tmp.block.hashPrevBlock  = pblock->hashPrevBlock;
    tmp.block.hashMerkleRoot = pblock->hashMerkleRoot;
    tmp.block.nTime          = pblock->nTime;
    tmp.block.nBits          = pblock->nBits;
    tmp.block.nNonce         = pblock->nNonce;

    FormatHashBlocks(&tmp.block, sizeof(tmp.block));
    FormatHashBlocks(&tmp.hash1, sizeof(tmp.hash1));

    // Byte swap all the input buffer
    for (unsigned int i = 0; i < sizeof(tmp)/4; i++)
        ((unsigned int*)&tmp)[i] = ByteReverse(((unsigned int*)&tmp)[i]);

    // Precalc the first half of the first hash, which stays constant
    SHA256Transform(pmidstate, &tmp.block, pSHA256InitState);

    memcpy(pdata, &tmp.block, 128);
    memcpy(phash1, &tmp.hash1, 64);
}


bool CheckWork(CBlock* pblock, CWallet& wallet, CReserveKey& reservekey)
{
    uint256 hashBlock = pblock->GetHash();
    uint256 hashTarget = CBigNum().SetCompact(pblock->nBits).getuint256();

    if(!pblock->IsProofOfWork())
        return error("CheckWork() : %s is not a proof-of-work block", hashBlock.GetHex().c_str());

    if (hashBlock > hashTarget)
        return error("CheckWork() : proof-of-work not meeting target");

    //// debug print
    printf("CheckWork() : new proof-of-work block found  \n  hash: %s  \ntarget: %s\n", hashBlock.GetHex().c_str(), hashTarget.GetHex().c_str());
    pblock->print();
    printf("generated %s\n", FormatMoney(pblock->vtx[0].vout[0].nValue).c_str());

    // Found a solution
    {
        LOCK(cs_main);
        if (pblock->hashPrevBlock != hashBestChain)
            return error("CheckWork() : generated block is stale");

        // Remove key from key pool
        reservekey.KeepKey();

        // Track how many getdata requests this block gets
        {
            LOCK(wallet.cs_wallet);
            wallet.mapRequestCount[hashBlock] = 0;
        }

        // Process this block the same as if we had received it from another node
        if (!ProcessBlock(NULL, pblock))
            return error("CheckWork() : ProcessBlock, block not accepted");
    }

    return true;
}

bool CheckStake(CBlock* pblock, CWallet& wallet)
{
    uint256 proofHash = 0, hashTarget = 0;
    uint256 hashBlock = pblock->GetHash();

    if(!pblock->IsProofOfStake())
        return error("CheckStake() : %s is not a proof-of-stake block", hashBlock.GetHex().c_str());

    // verify hash target and signature of coinstake tx
    if (!CheckProofOfStake(pblock->vtx[1], pblock->nBits, proofHash, hashTarget))
        return error("CheckStake() : proof-of-stake checking failed");

    //// debug print
    printf("CheckStake() : new proof-of-stake block found  \n  hash: %s \nproofhash: %s  \ntarget: %s\n", hashBlock.GetHex().c_str(), proofHash.GetHex().c_str(), hashTarget.GetHex().c_str());
    pblock->print();
    printf("out %s\n", FormatMoney(pblock->vtx[1].GetValueOut()).c_str());

    // Found a solution
    {
        LOCK(cs_main);
        if (pblock->hashPrevBlock != hashBestChain)
            return error("CheckStake() : generated block is stale");

        // Track how many getdata requests this block gets
        {
            LOCK(wallet.cs_wallet);
            wallet.mapRequestCount[hashBlock] = 0;
        }

        // Process this block the same as if we had received it from another node
        if (!ProcessBlock(NULL, pblock))
            return error("CheckStake() : ProcessBlock, block not accepted");
    }

    return true;
}

void StakeMiner(CWallet *pwallet)
{
    SetThreadPriority(THREAD_PRIORITY_LOWEST);

    // Make this thread recognisable as the mining thread
    RenameThread("gnosis-miner");

    bool fTryToSync = true;

    while (true)
    {
        if (fShutdown)
            return;

        while (pwallet->IsLocked())
        {
            nLastCoinStakeSearchInterval = 0;
            MilliSleep(1000);
            if (fShutdown)
                return;
        }

        while (vNodes.empty() || IsInitialBlockDownload())
        {
            nLastCoinStakeSearchInterval = 0;
            fTryToSync = true;
            MilliSleep(1000);
            if (fShutdown)
                return;
        }

        if (fTryToSync)
        {
            fTryToSync = false;
            if (vNodes.size() < 3 || nBestHeight < GetNumBlocksOfPeers())
            {
                MilliSleep(60000);
                continue;
            }
        }

        //
        // Create new block
        //
        int64_t nFees;
        auto_ptr<CBlock> pblock(CreateNewBlock(pwallet, true, &nFees));
        if (!pblock.get())
            return;

        // Trying to sign a block
        if (pblock->SignBlock(*pwallet, nFees))
        {
            SetThreadPriority(THREAD_PRIORITY_NORMAL);
            CheckStake(pblock.get(), *pwallet);
            SetThreadPriority(THREAD_PRIORITY_LOWEST);
            MilliSleep(500);
        }
        else
            MilliSleep(nMinerSleep);
    }
}
